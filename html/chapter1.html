<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第一章：导论</title>
    <link rel="stylesheet" href="./assets/style.css">
    <link rel="stylesheet" href="./assets/highlight.css">
    <script src="./assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <ul class="nav-list"><li class=""><a href="./index.html">高级物理引擎实战教程</a></li><li class="active"><a href="./chapter1.html">第一章：导论</a></li><li class=""><a href="./chapter2.html">第二章：拉格朗日视角（1）</a></li><li class=""><a href="./chapter3.html">第三章：拉格朗日视角（2）：有限元仿真</a></li><li class=""><a href="./chapter4.html">第四章：欧拉视角（1）</a></li><li class=""><a href="./chapter5.html">第五章：欧拉视角（2）：线性系统求解器</a></li><li class=""><a href="./chapter6.html">第六章：高级输送格式与等势面方法</a></li><li class=""><a href="./chapter7.html">第七章：混合欧拉-拉格朗日视角（1）</a></li><li class=""><a href="./chapter8.html">第八章：混合欧拉-拉格朗日视角（2）：物质点法</a></li><li class=""><a href="./chapter9.html">第九章：高性能计算</a></li><li class=""><a href="./chapter10.html">第十章：可微编程与机器学习</a></li><li class=""><a href="./chapter8b.html">第八章：多重网格方法</a></li><li class=""><a href="./CLAUDE.html">Untitled</a></li><li class=""><a href="./old.html">Untitled</a></li></ul>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="_1">第一章：导论</h1>
<p>本章将为读者建立物理仿真的基础知识框架，并深入介绍Taichi编程语言的核心特性。我们将从物理引擎的基本概念出发，逐步深入到高性能并行计算的实现细节。通过本章学习，读者将掌握使用Taichi进行物理仿真开发所需的全部基础知识。</p>
<h2 id="11">1.1 基于物理的动画简介</h2>
<h3 id="111">1.1.1 物理引擎的定义与应用领域</h3>
<p>物理引擎是一类专门用于模拟物理系统行为的计算机软件。它通过数值方法求解物理方程，为虚拟世界中的物体提供逼真的运动和交互效果。现代物理引擎通常包含三大核心组件：</p>
<ol>
<li><strong>刚体动力学</strong>：模拟不可变形物体的运动，处理碰撞检测与响应</li>
<li><strong>软体动力学</strong>：模拟可变形物体如布料、橡胶、肌肉等的形变行为  </li>
<li><strong>流体动力学</strong>：模拟液体和气体的流动，包括水波、烟雾等效果</li>
</ol>
<p>物理引擎的应用领域极其广泛：</p>
<ul>
<li><strong>游戏产业</strong>：从简单的《愤怒的小鸟》到复杂的《围攻》(Besiege)，物理引擎让游戏世界更加真实</li>
<li><strong>影视特效</strong>：迪士尼、皮克斯等顶级动画工作室依赖物理仿真创造震撼视觉效果</li>
<li><strong>工程仿真</strong>：汽车碰撞测试、建筑结构分析、流体机械设计等</li>
<li><strong>虚拟现实</strong>：提供真实的触觉反馈和物理交互体验</li>
<li><strong>机器人学</strong>：训练和验证机器人控制算法的虚拟环境</li>
</ul>
<h3 id="112">1.1.2 计算机图形学中的物理仿真</h3>
<p>在计算机图形学的发展历程中，物理仿真扮演着越来越重要的角色。早期的动画完全依赖艺术家手工关键帧，而现代制作流程已经深度集成了物理仿真技术：</p>
<p><strong>传统动画 vs 物理动画</strong>：</p>
<ul>
<li>传统动画：艺术家控制每一帧，灵活但耗时</li>
<li>物理动画：定义初始条件和物理参数，自动生成逼真运动</li>
</ul>
<p><strong>里程碑作品</strong>：</p>
<ul>
<li>1997年《泰坦尼克号》：大规模刚体破碎和流体仿真</li>
<li>2013年《冰雪奇缘》：基于物质点法(MPM)的雪景仿真</li>
<li>2016年《海洋奇缘》：高度逼真的水体和头发仿真</li>
</ul>
<p><strong>技术演进</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="mi">1980</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="err">简单粒子系统</span>
<span class="mi">1990</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="err">刚体动力学成熟</span>
<span class="mi">2000</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="err">流体仿真突破（</span><span class="n">SPH</span><span class="err">、</span><span class="n">FLIP</span><span class="err">）</span>
<span class="mi">2010</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="err">统一仿真框架（</span><span class="n">MPM</span><span class="err">）</span>
<span class="mi">2020</span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="err">机器学习增强、实时光线追踪物理</span>
</code></pre></div>

<h3 id="113-cae">1.1.3 工程CAE与游戏物理的差异</h3>
<p>虽然都是物理仿真，但工程计算机辅助工程(CAE)与游戏物理在设计理念上存在本质差异：</p>
<p>| 特性 | 工程CAE | 游戏物理 |</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>工程CAE</th>
<th>游戏物理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>精度要求</strong></td>
<td>误差 &lt; 1%，需要验证</td>
<td>视觉合理即可</td>
</tr>
<tr>
<td><strong>实时性</strong></td>
<td>可以离线计算数小时</td>
<td>必须 60 FPS</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>绝对稳定，不允许崩溃</td>
<td>偶尔穿模可接受</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>百万级自由度</td>
<td>千级自由度</td>
</tr>
<tr>
<td><strong>物理真实性</strong></td>
<td>严格遵循物理定律</td>
<td>可以作弊提升体验</td>
</tr>
</tbody>
</table>
<p><strong>工程CAE的典型流程</strong>：</p>
<ol>
<li>几何建模（CAD）</li>
<li>网格生成（六面体/四面体）</li>
<li>边界条件设置</li>
<li>求解器计算（可能需要数小时）</li>
<li>后处理可视化</li>
</ol>
<p><strong>游戏物理的设计原则</strong>：</p>
<ol>
<li>性能优先：宁可牺牲精度也要保证帧率</li>
<li>鲁棒性：处理各种极端情况不崩溃</li>
<li>可控性：艺术家/设计师可以调整参数</li>
<li>确定性：相同输入产生相同结果（重要于网络同步）</li>
</ol>
<h3 id="114">1.1.4 实时性与精确性的权衡</h3>
<p>在物理仿真中，实时性和精确性往往不可兼得。理解这种权衡对于选择合适的算法至关重要：</p>
<p><strong>时间步长的选择</strong>：</p>
<ul>
<li>显式积分器的稳定性条件：$\Delta t \leq c\sqrt{\frac{m}{k}}$</li>
<li>隐式积分器：无条件稳定但每步计算量大</li>
<li>自适应时间步长：根据场景动态调整</li>
</ul>
<p><strong>模型简化技术</strong>：</p>
<ol>
<li>
<p><strong>几何简化</strong>：
   - 碰撞用简化凸包代替复杂网格
   - LOD (Level of Detail) 根据距离切换精度</p>
</li>
<li>
<p><strong>物理简化</strong>：
   - 刚体近似：忽略小变形
   - 质点近似：远距离物体视为质点
   - 维度降低：3D布料用2D壳体模拟</p>
</li>
<li>
<p><strong>数值简化</strong>：
   - 低阶积分格式
   - 稀疏更新（只更新活跃区域）
   - 预计算查找表</p>
</li>
</ol>
<p><strong>性能优化层次</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="err">算法级</span><span class="o">:</span><span class="w"> </span><span class="n">O</span><span class="o">(</span><span class="n">n²</span><span class="o">)</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">O</span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="n">log</span><span class="w"> </span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">O</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="err">并行级</span><span class="o">:</span><span class="w"> </span><span class="n">CPU多线程</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">GPU大规模并行</span>
<span class="err">近似级</span><span class="o">:</span><span class="w"> </span><span class="err">精确解</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">数值解</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">启发式解</span>
</code></pre></div>

<h2 id="12-taichi">1.2 Taichi编程语言简介</h2>
<h3 id="121">1.2.1 安装与环境配置</h3>
<p>Taichi是一个专为高性能数值计算设计的编程语言，特别适合物理仿真。其最大特点是将Python的易用性与C++的性能完美结合。</p>
<p><strong>安装方式</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 推荐使用pip安装</span>
pip<span class="w"> </span>install<span class="w"> </span>taichi

<span class="c1"># 对于开发版本</span>
pip<span class="w"> </span>install<span class="w"> </span>taichi-nightly

<span class="c1"># 验证安装</span>
python<span class="w"> </span>-c<span class="w"> </span><span class="s2">&quot;import taichi as ti; ti.init(); print(ti.__version__)&quot;</span>
</code></pre></div>

<p><strong>支持平台</strong>：</p>
<ul>
<li>操作系统：Windows、Linux、macOS</li>
<li>Python版本：3.6-3.10</li>
<li>后端支持：</li>
<li>CPU：x64、ARM64</li>
<li>GPU：CUDA（NVIDIA）、Vulkan（跨平台）、Metal（Apple）</li>
<li>WebGPU：浏览器端运行</li>
</ul>
<p><strong>初始化配置</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">taichi</span> <span class="k">as</span> <span class="nn">ti</span>

<span class="c1"># 基本初始化</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cuda</span><span class="p">)</span>  <span class="c1"># 选择CUDA后端</span>

<span class="c1"># 高级配置</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span>
    <span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">gpu</span><span class="p">,</span>           <span class="c1"># 自动选择可用GPU</span>
    <span class="n">device_memory_GB</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>    <span class="c1"># 限制GPU内存使用</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>            <span class="c1"># 开启调试模式</span>
    <span class="n">print_ir</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>         <span class="c1"># 打印中间表示</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span>         <span class="c1"># 固定随机种子</span>
<span class="p">)</span>
</code></pre></div>

<h3 id="122">1.2.2 基本数据类型与张量操作</h3>
<p>Taichi提供了丰富的数据类型和张量操作，专门针对科学计算优化：</p>
<p><strong>基本数据类型</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 标量类型</span>
<span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">i64</span>    <span class="c1"># 32/64位整数</span>
<span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f64</span>    <span class="c1"># 32/64位浮点数</span>
<span class="n">ti</span><span class="o">.</span><span class="n">u8</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">u16</span>     <span class="c1"># 无符号整数</span>

<span class="c1"># 类型推断</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div>

<p><strong>张量（Tensor）定义</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 标量场</span>
<span class="n">temperature</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>

<span class="c1"># 向量场</span>
<span class="n">velocity</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

<span class="c1"># 矩阵场</span>
<span class="n">stress</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>

<span class="c1"># 动态形状（高级用法）</span>
<span class="n">particles</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
<span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dynamic</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
</code></pre></div>

<p><strong>张量操作</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">tensor_operations</span><span class="p">():</span>
    <span class="c1"># 向量运算</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">])</span>

    <span class="n">dot_product</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>              <span class="c1"># 点积: 32.0</span>
    <span class="n">cross_product</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>          <span class="c1"># 叉积: [-3, 6, -3]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>                     <span class="c1"># 范数: sqrt(14)</span>
    <span class="n">normalized</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>         <span class="c1"># 单位向量</span>

    <span class="c1"># 矩阵运算</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
    <span class="n">M_inv</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>                 <span class="c1"># 逆矩阵</span>
    <span class="n">M_T</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>                 <span class="c1"># 转置</span>
    <span class="n">det</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">determinant</span><span class="p">()</span>               <span class="c1"># 行列式: -2</span>

    <span class="c1"># 特殊矩阵</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># 3x3单位矩阵</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">zero</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># 2x3零矩阵</span>
</code></pre></div>

<h3 id="123-kernelfunc">1.2.3 核函数(kernel)与函数(func)</h3>
<p>Taichi的计算核心是kernel和func，它们定义了可以在GPU上高效执行的计算：</p>
<p><strong>Kernel函数</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
    <span class="c1"># Kernel是Taichi程序的入口点</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
        <span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>

<span class="c1"># Kernel可以有返回值</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">sum_field</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">:</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span>
</code></pre></div>

<p><strong>Func函数</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">func</span>
<span class="k">def</span> <span class="nf">complex_calculation</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">:</span>
    <span class="c1"># Func只能被Kernel或其他Func调用</span>
    <span class="c1"># 会被强制内联，无函数调用开销</span>
    <span class="k">return</span> <span class="n">ti</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">use_func</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
        <span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">complex_calculation</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span>
</code></pre></div>

<p><strong>类型提示与模板</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 严格类型提示</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">typed_kernel</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">2.0</span>

<span class="c1"># 模板参数</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">generic_kernel</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">scalar</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
        <span class="n">field</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scalar</span>
</code></pre></div>

<p><strong>编译时优化</strong>：</p>
<ul>
<li>常量折叠：编译时计算常量表达式</li>
<li>死代码消除：移除不可达代码</li>
<li>循环展开：小循环自动展开</li>
<li>向量化：自动SIMD指令生成</li>
</ul>
<h3 id="124-for">1.2.4 并行for循环与原子操作</h3>
<p>Taichi的一个核心特性是自动并行化，开发者只需要写串行代码，编译器会自动并行执行：</p>
<p><strong>并行For循环</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">parallel_computation</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">):</span>
    <span class="c1"># 这个循环会自动并行执行</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># 每个迭代独立，无数据竞争</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ti</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">0.2</span><span class="p">)</span>

    <span class="c1"># 多维并行循环</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">):</span>
        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>
</code></pre></div>

<p><strong>原子操作</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span> 
<span class="k">def</span> <span class="nf">atomic_operations</span><span class="p">():</span>
    <span class="c1"># 处理并发写入冲突</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="c1"># 原子加法，保证线程安全</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="n">total</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># 原子最大值</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">atomic_max</span><span class="p">(</span><span class="n">max_value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># 原子交换</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">atomic_sub</span><span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 复合原子操作</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># 自动识别并转换为原子操作</span>
        <span class="n">histogram</span><span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>

<p><strong>竞态条件的避免</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 错误示例 - 有竞态条件</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">race_condition</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="c1"># 多个线程可能同时读写</span>
        <span class="n">shared_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">shared_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span>  <span class="c1"># 危险！</span>

<span class="c1"># 正确示例 - 使用原子操作</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span> 
<span class="k">def</span> <span class="nf">no_race_condition</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="n">shared_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>  <span class="c1"># 安全</span>
</code></pre></div>

<p><strong>性能考虑</strong>：</p>
<ul>
<li>原子操作比普通操作慢10-100倍</li>
<li>尽量减少原子操作的使用</li>
<li>考虑使用归约(reduction)模式</li>
<li>合理的数据布局可以避免冲突</li>
</ul>
<h2 id="13-taichi">1.3 Taichi的自动并行化</h2>
<h3 id="131">1.3.1 并行计算基础概念</h3>
<p>理解Taichi的自动并行化机制，首先需要掌握并行计算的基本概念：</p>
<p><strong>并行计算模型</strong>：</p>
<ol>
<li>
<p><strong>数据并行(Data Parallelism)</strong>：
   - 相同操作应用于不同数据
   - SIMD (Single Instruction Multiple Data)
   - 适合规则的数组运算</p>
</li>
<li>
<p><strong>任务并行(Task Parallelism)</strong>：
   - 不同任务同时执行
   - MIMD (Multiple Instruction Multiple Data)
   - 适合异构计算任务</p>
</li>
</ol>
<p><strong>GPU执行模型(SIMT)</strong>：</p>
<div class="codehilite"><pre><span></span><code>GPU执行层次：
Grid
├── Block (0,0)
│   ├── Warp 0 (32 threads)
│   ├── Warp 1 (32 threads)
│   └── ...
├── Block (0,1)
└── ...
</code></pre></div>

<p><strong>并行粒度</strong>：</p>
<ul>
<li>细粒度：每个数据元素一个线程</li>
<li>中粒度：数据块级别并行</li>
<li>粗粒度：任务级别并行</li>
</ul>
<p>Taichi采用细粒度数据并行，自动将循环映射到GPU线程。</p>
<h3 id="132-range-forstruct-for">1.3.2 Range-for与Struct-for循环</h3>
<p>Taichi提供两种主要的并行循环结构：</p>
<p><strong>Range-for循环</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">range_for_examples</span><span class="p">():</span>
    <span class="c1"># 一维循环</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span>

    <span class="c1"># 多维循环 - 使用ti.ndrange</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span>

    <span class="c1"># 带步长的循环</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">even_array</span><span class="p">[</span><span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="c1"># 嵌套循环优化</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">):</span>
        <span class="c1"># 编译器会优化循环顺序以提高缓存局部性</span>
        <span class="n">volume</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span>
</code></pre></div>

<p><strong>Struct-for循环</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 稀疏数据结构定义</span>
<span class="n">block</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">pointer</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">pixel</span> <span class="o">=</span> <span class="n">block</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">ij</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">pixel</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">sparse_field</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">struct_for_example</span><span class="p">():</span>
    <span class="c1"># 只遍历激活的元素</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sparse_field</span><span class="p">:</span>
        <span class="n">sparse_field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">2.0</span>

    <span class="c1"># 分层遍历</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">block</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Active block at (</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>ti.grouped优化</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">grouped_access</span><span class="p">():</span>
    <span class="c1"># 将多维索引打包为单个变量</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">tensor_3d</span><span class="p">):</span>
        <span class="c1"># I是一个向量，包含所有维度的索引</span>
        <span class="n">tensor_3d</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>  <span class="c1"># 自动展开为 i*i + j*j + k*k</span>
</code></pre></div>

<p><strong>并行化规则</strong>：</p>
<ol>
<li>最外层循环自动并行</li>
<li>内层循环保持串行</li>
<li>循环迭代必须独立</li>
<li>不支持break/continue</li>
</ol>
<h3 id="133">1.3.3 线程安全与竞态条件</h3>
<p>在并行编程中，正确处理共享数据访问至关重要：</p>
<p><strong>竞态条件示例</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 危险代码 - 竞态条件</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">race_example</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        <span class="c1"># 多个线程同时读-修改-写</span>
        <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 结果不确定！</span>

<span class="c1"># 安全代码 - 原子操作</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">safe_example</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 保证正确结果</span>
</code></pre></div>

<p><strong>Taichi的安全保证</strong>：</p>
<ol>
<li><strong>自动原子化</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># Taichi自动识别并转换</span>
<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>  <span class="c1"># 自动转换为atomic_add</span>
<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  <span class="c1"># 自动转换为atomic_max</span>
</code></pre></div>

<ol start="2">
<li>
<p><strong>支持的原子操作</strong>：
   - <code>atomic_add</code>, <code>atomic_sub</code>
   - <code>atomic_min</code>, <code>atomic_max</code>
   - <code>atomic_and</code>, <code>atomic_or</code>, <code>atomic_xor</code>
   - <code>atomic_exchange</code> (原子交换)</p>
</li>
<li>
<p><strong>线程局部存储</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">thread_local_example</span><span class="p">():</span>
    <span class="c1"># 每个线程有自己的局部变量</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">local_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">local_sum</span> <span class="o">+=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">row_sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_sum</span>
</code></pre></div>

<p><strong>避免竞态的策略</strong>：</p>
<ol>
<li>数据分区：每个线程处理独立数据</li>
<li>归约模式：使用树形归约减少冲突</li>
<li>双缓冲：读写分离到不同缓冲区</li>
<li>原子操作：必要时使用但注意性能</li>
</ol>
<h3 id="134">1.3.4 性能分析与调优基础</h3>
<p>理解和优化Taichi程序性能的关键工具和技术：</p>
<p><strong>内置性能分析器</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 启用性能分析</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cuda</span><span class="p">,</span> <span class="n">kernel_profiler</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">computation</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">ti</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># 执行并打印性能报告</span>
<span class="n">computation</span><span class="p">()</span>
<span class="n">ti</span><span class="o">.</span><span class="n">print_kernel_profile_info</span><span class="p">()</span>
</code></pre></div>

<p><strong>性能指标</strong>：</p>
<ol>
<li><strong>kernel时间</strong>：GPU执行时间</li>
<li><strong>内存带宽</strong>：数据传输速率</li>
<li><strong>占用率</strong>：活跃线程比例</li>
<li><strong>缓存命中率</strong>：数据局部性</li>
</ol>
<p><strong>常见性能问题</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 问题1：内存访问模式差</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">bad_access_pattern</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">):</span>
        <span class="c1"># 列优先访问，缓存不友好</span>
        <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># 优化：行优先访问</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span> 
<span class="k">def</span> <span class="nf">good_access_pattern</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">):</span>
        <span class="c1"># 行优先访问，缓存友好</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># 问题2：过多原子操作</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">too_many_atomics</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="nb">sum</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">10</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 高冲突</span>

<span class="c1"># 优化：线程局部累加</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">optimized_histogram</span><span class="p">():</span>
    <span class="c1"># 使用线程局部数组减少冲突</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">local_hist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="c1"># 先本地累加</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
            <span class="n">local_hist</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># 再原子更新全局</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="n">histogram</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">local_hist</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
</code></pre></div>

<p><strong>优化技巧清单</strong>：</p>
<ol>
<li>合并内存访问</li>
<li>减少分支分歧</li>
<li>使用共享内存</li>
<li>循环展开</li>
<li>避免存储bank冲突</li>
</ol>
<h2 id="14-taichi">1.4 Taichi程序的调试技巧</h2>
<h3 id="141">1.4.1 调试模式与边界检查</h3>
<p>调试是开发高质量代码的关键环节，Taichi提供了丰富的调试工具：</p>
<p><strong>启用调试模式</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 完整调试模式</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">cpu</span><span class="p">)</span>

<span class="c1"># 调试选项详解</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span>
    <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>           <span class="c1"># 启用所有调试检查</span>
    <span class="n">print_ir</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>        <span class="c1"># 打印中间表示</span>
    <span class="n">print_kernel_llvm_ir</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># 打印LLVM IR</span>
    <span class="n">check_out_of_bound</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>    <span class="c1"># 边界检查</span>
<span class="p">)</span>
</code></pre></div>

<p><strong>边界检查器</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">boundary_check_example</span><span class="p">():</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="c1"># 调试模式下会检测越界</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">101</span><span class="p">):</span>  <span class="c1"># 错误：越界访问</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># 运行时错误：index 100 out of bound [0, 100)</span>

    <span class="c1"># 安全的访问方式</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>  <span class="c1"># 显式边界检查</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</code></pre></div>

<p><strong>断言使用</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">debug_with_assert</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># 运行时断言</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Value </span><span class="si">{</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> out of range&quot;</span>

        <span class="c1"># 计算前置条件检查</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">compute_denominator</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">denominator</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Division by zero&quot;</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numerator</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">denominator</span>
</code></pre></div>

<h3 id="142">1.4.2 打印调试与断言</h3>
<p>Taichi支持在kernel中打印，这是调试的重要工具：</p>
<p><strong>打印功能</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">print_debugging</span><span class="p">():</span>
    <span class="c1"># 基本打印</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting computation&quot;</span><span class="p">)</span>

    <span class="c1"># 打印变量</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;i = </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, value = </span><span class="si">{</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># 条件打印</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Progress: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">/1000&quot;</span><span class="p">)</span>

    <span class="c1"># 打印向量和矩阵</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Vector:&quot;</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="s2">&quot;Matrix:&quot;</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>
</code></pre></div>

<p><strong>打印限制与最佳实践</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">print_best_practices</span><span class="p">():</span>
    <span class="c1"># 限制打印数量避免输出爆炸</span>
    <span class="n">print_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">print_count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Negative value at </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">print_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># 使用统计而非逐个打印</span>
    <span class="n">error_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_error</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">error_count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total errors: </span><span class="si">{</span><span class="n">error_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="143">1.4.3 常见错误与解决方案</h3>
<p><strong>错误类型1：越界访问</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 错误示例</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">out_of_bound_error</span><span class="p">():</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>  <span class="c1"># 错误！</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># 解决方案</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">safe_access</span><span class="p">():</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>  <span class="c1"># 使用field自身作为范围</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

<p><strong>错误类型2：类型不匹配</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 错误示例</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">type_mismatch</span><span class="p">():</span>
    <span class="n">int_field</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">int_field</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.14</span>  <span class="c1"># 错误：浮点数赋值给整数</span>

<span class="c1"># 解决方案</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">correct_types</span><span class="p">():</span>
    <span class="n">int_field</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">int_field</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>  <span class="c1"># 显式类型转换</span>
</code></pre></div>

<p><strong>错误类型3：未初始化变量</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 错误示例</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">uninitialized_error</span><span class="p">():</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="nb">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 错误：sum[0]未初始化</span>

<span class="c1"># 解决方案</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">proper_initialization</span><span class="p">():</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># 显式初始化</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="nb">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></div>

<p><strong>错误类型4：并行冲突</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 错误示例</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">parallel_conflict</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># 多个线程写入相同位置</span>
        <span class="n">shared_array</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># 结果不确定</span>

<span class="c1"># 解决方案</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">conflict_resolution</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># 使用原子操作</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">atomic_max</span><span class="p">(</span><span class="n">shared_array</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
</code></pre></div>

<h3 id="144">1.4.4 性能瓶颈识别</h3>
<p>识别和解决性能瓶颈是优化的关键：</p>
<p><strong>性能分析工具</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># 手动计时</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">timed_kernel</span><span class="p">():</span>
    <span class="c1"># kernel代码</span>
    <span class="k">pass</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">timed_kernel</span><span class="p">()</span>
<span class="n">ti</span><span class="o">.</span><span class="n">sync</span><span class="p">()</span>  <span class="c1"># 重要：等待GPU完成</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Average time: </span><span class="si">{</span><span class="p">(</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>

<span class="c1"># 使用Taichi profiler</span>
<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">kernel_profiler</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># 运行kernels</span>
<span class="n">ti</span><span class="o">.</span><span class="n">print_kernel_profile_info</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>  <span class="c1"># 按时间排序</span>
</code></pre></div>

<p><strong>常见性能瓶颈</strong>：</p>
<ol>
<li><strong>内存带宽限制</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 问题：随机内存访问</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">random_access</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>  <span class="c1"># 缓存不友好</span>

<span class="c1"># 优化：顺序访问</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">sequential_access</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 缓存友好</span>
</code></pre></div>

<ol start="2">
<li><strong>计算瓶颈</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 问题：复杂数学运算</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">expensive_math</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>

<span class="c1"># 优化：查表或近似</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">optimized_math</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># 使用泰勒展开或查找表</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fast_approximation</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</code></pre></div>

<ol start="3">
<li><strong>核函数粒度</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1"># 问题：kernel太小，启动开销大</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="n">small_kernel</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1"># 1000次kernel启动</span>

<span class="c1"># 优化：批处理</span>
<span class="n">large_kernel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># 1次kernel启动</span>
</code></pre></div>

<h2 id="15-dop">1.5 面向数据的编程(DOP)</h2>
<h3 id="151-aos-vs-soa">1.5.1 AoS vs SoA布局</h3>
<p>数据布局对性能有决定性影响，理解AoS(Array of Structures)和SoA(Structure of Arrays)的差异至关重要：</p>
<p><strong>AoS布局示例</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Array of Structures - 数据按对象组织</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">ParticleSystemAoS</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Struct</span><span class="o">.</span><span class="n">field</span><span class="p">({</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span>
            <span class="s1">&#39;vx&#39;</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span>
            <span class="s1">&#39;vy&#39;</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span>
            <span class="s1">&#39;mass&#39;</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span>
        <span class="p">},</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">update_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">:</span>
            <span class="c1"># 访问同一粒子的不同属性 - 缓存友好</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">vy</span> <span class="o">*</span> <span class="n">dt</span>
</code></pre></div>

<p><strong>SoA布局示例</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Structure of Arrays - 数据按属性组织</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">ParticleSystemSoA</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">update_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># 访问不同数组的相同索引 - SIMD友好</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
</code></pre></div>

<p><strong>性能对比</strong>：</p>
<p>| 操作类型 | AoS | SoA |</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>AoS</th>
<th>SoA</th>
</tr>
</thead>
<tbody>
<tr>
<td>单对象全属性访问</td>
<td>优秀</td>
<td>较差</td>
</tr>
<tr>
<td>批量单属性处理</td>
<td>较差</td>
<td>优秀</td>
</tr>
<tr>
<td>SIMD向量化</td>
<td>困难</td>
<td>简单</td>
</tr>
<tr>
<td>缓存利用率</td>
<td>取决于访问模式</td>
<td>通常更好</td>
</tr>
</tbody>
</table>
<p><strong>混合策略</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># AoSoA - Array of Structure of Arrays</span>
<span class="c1"># 结合两者优势</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">HybridLayout</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="mi">32</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Struct</span><span class="o">.</span><span class="n">field</span><span class="p">({</span>
            <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">),</span>
            <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">),</span>
            <span class="s1">&#39;vx&#39;</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">),</span>
            <span class="s1">&#39;vy&#39;</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)</span>
        <span class="p">},</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span> <span class="o">//</span> <span class="n">block_size</span><span class="p">)</span>
</code></pre></div>

<h3 id="152">1.5.2 缓存友好的数据组织</h3>
<p>现代处理器的性能瓶颈往往是内存访问而非计算，优化数据布局至关重要：</p>
<p><strong>缓存层级</strong>：</p>
<div class="codehilite"><pre><span></span><code>寄存器: ~1 cycle
L1缓存: ~4 cycles (32KB)
L2缓存: ~12 cycles (256KB)
L3缓存: ~40 cycles (8MB)
主内存: ~200 cycles
</code></pre></div>

<p><strong>空间局部性优化</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 差：跨步访问</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">poor_spatial_locality</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="c1"># 每次访问跳过m个元素</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span>

<span class="c1"># 好：连续访问</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>  
<span class="k">def</span> <span class="nf">good_spatial_locality</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="c1"># 连续内存访问</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span>
</code></pre></div>

<p><strong>时间局部性优化</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 差：反复加载相同数据</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">poor_temporal_locality</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

<span class="c1"># 好：分块矩阵乘法</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">blocked_matmul</span><span class="p">():</span>
    <span class="n">tile_size</span> <span class="o">=</span> <span class="mi">32</span>
    <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">tile_size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">bj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">tile_size</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">tile_size</span><span class="p">):</span>
                <span class="c1"># 处理tile_size x tile_size的块</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">bi</span> <span class="o">+</span> <span class="n">tile_size</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bj</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">bj</span> <span class="o">+</span> <span class="n">tile_size</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bk</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">bk</span> <span class="o">+</span> <span class="n">tile_size</span><span class="p">,</span> <span class="n">p</span><span class="p">)):</span>
                            <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
</code></pre></div>

<p><strong>数据对齐</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 确保数据对齐到缓存行(64字节)</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">AlignedData</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Taichi自动处理对齐</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span>

        <span class="c1"># 手动填充避免伪共享</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>  <span class="c1"># 填充到缓存行</span>
</code></pre></div>

<h3 id="153">1.5.3 内存访问模式优化</h3>
<p>不同的内存访问模式对性能影响巨大：</p>
<p><strong>合并访问(Coalesced Access)</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># GPU上的合并访问</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">coalesced_access</span><span class="p">():</span>
    <span class="c1"># 好：相邻线程访问相邻内存</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">2.0</span>

    <span class="c1"># 差：跨步访问</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">stride</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">2.0</span>
</code></pre></div>

<p><strong>Bank冲突避免</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 共享内存bank冲突</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">bank_conflict_example</span><span class="p">():</span>
    <span class="n">shared_mem</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>

    <span class="c1"># 冲突：所有线程访问同一bank</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">shared_mem</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span>  <span class="c1"># 8路冲突</span>

    <span class="c1"># 无冲突：添加偏移</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">32</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">shared_mem</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span> <span class="o">%</span> <span class="mi">32</span><span class="p">]</span>
</code></pre></div>

<p><strong>预取策略</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">manual_prefetch</span><span class="p">():</span>
    <span class="c1"># 软件预取提示</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">prefetch_distance</span><span class="p">):</span>
        <span class="c1"># 预取未来要用的数据</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">prefetch_distance</span><span class="p">])</span>
        <span class="c1"># 处理当前数据</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">complex_computation</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</code></pre></div>

<h3 id="154">1.5.4 向量化编程技巧</h3>
<p>利用SIMD指令提升计算密集型代码性能：</p>
<p><strong>自动向量化</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">auto_vectorization</span><span class="p">():</span>
    <span class="c1"># Taichi自动向量化简单循环</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># 自动使用SIMD</span>

    <span class="c1"># 复杂操作可能阻止向量化</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 分支阻止向量化</span>
            <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</code></pre></div>

<p><strong>显式向量操作</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">explicit_vectorization</span><span class="p">():</span>
    <span class="c1"># 使用向量类型</span>
    <span class="n">vec_size</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">n_vec</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">vec_size</span>

    <span class="c1"># 向量化主循环</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vec</span><span class="p">):</span>
        <span class="n">vec_a</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
        <span class="n">vec_b</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)])</span>
        <span class="n">vec_c</span> <span class="o">=</span> <span class="n">vec_a</span> <span class="o">+</span> <span class="n">vec_b</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec_c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="c1"># 处理剩余元素</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vec</span> <span class="o">*</span> <span class="n">vec_size</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></div>

<p><strong>向量化友好的算法</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 归约操作的向量化</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">vectorized_reduction</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">:</span>
    <span class="c1"># 使用多个累加器减少依赖</span>
    <span class="n">sum0</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">sum1</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">sum2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">sum3</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># 4路展开</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">sum0</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">sum1</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">sum2</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">sum3</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>

    <span class="c1"># 合并结果</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">sum0</span> <span class="o">+</span> <span class="n">sum1</span> <span class="o">+</span> <span class="n">sum2</span> <span class="o">+</span> <span class="n">sum3</span>

    <span class="c1"># 处理剩余</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">n</span> <span class="o">//</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">total</span>
</code></pre></div>

<h2 id="16-oop">1.6 面向对象的编程(OOP)</h2>
<h3 id="161-taichi">1.6.1 Taichi中的类与装饰器</h3>
<p>Taichi支持面向对象编程，通过<code>@ti.data_oriented</code>装饰器实现：</p>
<p><strong>基本类定义</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">RigidBody</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">velocity</span><span class="p">):</span>
        <span class="c1"># 成员变量可以是Taichi fields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>

        <span class="c1"># 初始化</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocity</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">update_physics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="c1"># kernel可以作为成员函数</span>
        <span class="n">acceleration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">force</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+=</span> <span class="n">acceleration</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">func</span>
    <span class="k">def</span> <span class="nf">compute_kinetic_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">:</span>
        <span class="c1"># func也可以作为成员函数</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">norm_sqr</span><span class="p">()</span>
</code></pre></div>

<p><strong>继承与多态</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">Particle</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">ChargedParticle</span><span class="p">(</span><span class="n">Particle</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">E_field</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="c1"># 重写父类方法</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">:</span>
            <span class="c1"># 电场力</span>
            <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">E_field</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">force</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
</code></pre></div>

<h3 id="162-odop">1.6.2 ODOP设计模式</h3>
<p>ODOP (Objective Data-Oriented Programming) 结合OOP的抽象能力和DOP的性能优势：</p>
<p><strong>ODOP原则</strong>：</p>
<ol>
<li>数据和行为封装在类中</li>
<li>使用SoA布局优化性能</li>
<li>批量操作而非单对象操作</li>
<li>最小化虚函数调用</li>
</ol>
<p><strong>ODOP示例</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">ParticleSystem</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_particles</span><span class="p">):</span>
        <span class="c1"># SoA布局</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">max_particles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">max_particles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">life</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">max_particles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">max_particles</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">emit_particles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">vector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">)):</span>
        <span class="n">old_count</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">num</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">old_count</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">old_count</span> <span class="o">+</span> <span class="n">i</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span>
                    <span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span>
                <span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">life</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="c1"># 批量更新所有粒子</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="kc">None</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># 重力</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="mf">9.81</span> <span class="o">*</span> <span class="n">dt</span>
                <span class="c1"># 位置更新</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
                <span class="c1"># 生命值衰减</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">life</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dt</span> <span class="o">*</span> <span class="mf">0.5</span>
                <span class="c1"># 死亡检测</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">life</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>

<h3 id="163">1.6.3 太阳系仿真案例</h3>
<p>完整的面向对象太阳系仿真示例：</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">taichi</span> <span class="k">as</span> <span class="nn">ti</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="n">ti</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">gpu</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">CelestialBody</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">compute_force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="mf">6.67430e-11</span>  <span class="c1"># 引力常数</span>

        <span class="c1"># 清零力</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="c1"># 计算万有引力</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">r_mag</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">r_mag</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>  <span class="c1"># 避免除零</span>
                        <span class="n">F_mag</span> <span class="o">=</span> <span class="n">G</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">r_mag</span> <span class="o">*</span> <span class="n">r_mag</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">F_mag</span> <span class="o">*</span> <span class="n">r</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">update_verlet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="c1"># Velocity Verlet积分</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="c1"># 更新位置</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span> \
                               <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">dt</span>

        <span class="c1"># 重新计算力</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_force</span><span class="p">()</span>

        <span class="c1"># 更新速度</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>

    <span class="k">def</span> <span class="nf">initialize_solar_system</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 太阳</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.989e30</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">6.96e8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="c1"># 地球</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">5.972e24</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">1.496e11</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.978e4</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">6.371e6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

        <span class="c1"># 更多行星...</span>
</code></pre></div>

<h3 id="164">1.6.4 代码复用与模块化</h3>
<p>良好的OOP设计促进代码复用：</p>
<p><strong>组件化设计</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">Transform</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;位置和方向组件&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># 四元数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>  
<span class="k">class</span> <span class="nc">Mesh</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;网格组件&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">GameObject</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;组合多个组件&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">physics</span> <span class="o">=</span> <span class="n">RigidBody</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">renderer</span> <span class="o">=</span> <span class="n">MeshRenderer</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="c1"># 协调各组件更新</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sync_transform</span><span class="p">()</span>
</code></pre></div>

<p><strong>接口设计</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">Integrator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;积分器接口&quot;&quot;&quot;</span>
    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">EulerIntegrator</span><span class="p">(</span><span class="n">Integrator</span><span class="p">):</span>
    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>  
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">position</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">state</span><span class="o">.</span><span class="n">velocity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>

<span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">VerletIntegrator</span><span class="p">(</span><span class="n">Integrator</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_position</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">dt</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">position</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">state</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">state</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
                               <span class="bp">self</span><span class="o">.</span><span class="n">prev_position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
                               <span class="n">state</span><span class="o">.</span><span class="n">force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">mass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
</code></pre></div>

<h2 id="17-mp">1.7 元编程(MP)</h2>
<h3 id="171">1.7.1 模板核函数</h3>
<p>Taichi的元编程允许编写高度通用和优化的代码：</p>
<p><strong>基本模板</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">copy_field</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">dst</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;通用的field复制函数&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
        <span class="n">dst</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>

<span class="c1"># 可用于任何维度和类型的field</span>
<span class="n">field_2d</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="n">field_3d</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="n">copy_field</span><span class="p">(</span><span class="n">field_2d</span><span class="p">,</span> <span class="n">another_2d_field</span><span class="p">)</span>
<span class="n">copy_field</span><span class="p">(</span><span class="n">field_3d</span><span class="p">,</span> <span class="n">another_3d_field</span><span class="p">)</span>
</code></pre></div>

<p><strong>参数化kernel</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">parametric_kernel</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> 
                     <span class="n">alpha</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span>
                     <span class="n">beta</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;编译时参数化&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
        <span class="c1"># alpha和beta在编译时确定</span>
        <span class="n">field</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">field</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">+</span> <span class="n">beta</span>

<span class="c1"># 为不同参数生成特化版本</span>
<span class="n">parametric_kernel</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>  <span class="c1"># 生成一个版本</span>
<span class="n">parametric_kernel</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>  <span class="c1"># 生成另一个版本</span>
</code></pre></div>

<h3 id="172">1.7.2 维度无关编程</h3>
<p>编写可以在2D/3D甚至更高维度工作的代码：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">laplacian</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">result</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;计算任意维度的拉普拉斯算子&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">result</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">))</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>

        <span class="c1"># 静态循环，编译时展开</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">))):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">unit</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">[</span><span class="n">I</span> <span class="o">-</span> <span class="n">offset</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>  <span class="c1"># 边界条件</span>

            <span class="k">if</span> <span class="n">I</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">[</span><span class="n">I</span> <span class="o">+</span> <span class="n">offset</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">[</span><span class="n">I</span><span class="p">]</span>  <span class="c1"># 边界条件</span>

<span class="c1"># 同一函数用于2D和3D</span>
<span class="n">field_2d</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="n">laplacian_2d</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="n">laplacian</span><span class="p">(</span><span class="n">field_2d</span><span class="p">,</span> <span class="n">laplacian_2d</span><span class="p">)</span>

<span class="n">field_3d</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="n">laplacian_3d</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="n">laplacian</span><span class="p">(</span><span class="n">field_3d</span><span class="p">,</span> <span class="n">laplacian_3d</span><span class="p">)</span>
</code></pre></div>

<p><strong>维度通用的物理仿真</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">data_oriented</span>
<span class="k">class</span> <span class="nc">GenericParticleSystem</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

    <span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
    <span class="k">def</span> <span class="nf">compute_pairwise_force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">zero</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                               <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">r_norm</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">r_norm</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                    <span class="c1"># Lennard-Jones势</span>
                    <span class="n">f_mag</span> <span class="o">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">r_norm</span><span class="o">**</span><span class="mi">14</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">r_norm</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">f_mag</span> <span class="o">*</span> <span class="n">r</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">force</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">force</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">f</span>
</code></pre></div>

<h3 id="173">1.7.3 编译时分支与循环展开</h3>
<p>利用<code>ti.static</code>进行编译时优化：</p>
<p><strong>静态分支</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">static_branching</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">mode</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
        <span class="c1"># 编译时决定分支</span>
        <span class="k">if</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;add&#39;</span><span class="p">):</span>
            <span class="n">field</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;mul&#39;</span><span class="p">):</span>
            <span class="n">field</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">2.0</span>
        <span class="k">elif</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;sin&#39;</span><span class="p">):</span>
            <span class="n">field</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="n">I</span><span class="p">])</span>

<span class="c1"># 生成三个不同的kernel版本</span>
<span class="n">static_branching</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>
<span class="n">static_branching</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;mul&#39;</span><span class="p">)</span>
<span class="n">static_branching</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s1">&#39;sin&#39;</span><span class="p">)</span>
</code></pre></div>

<p><strong>静态循环展开</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">matrix_vector_multiply</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> 
                          <span class="n">vec</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span>
                          <span class="n">result</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span>
                          <span class="n">n</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;编译时已知大小的矩阵向量乘法&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># 完全展开的循环</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

<span class="c1"># 为不同大小生成优化版本</span>
<span class="n">mat4</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
<span class="n">vec4</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
<span class="n">res4</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">())</span>
<span class="n">matrix_vector_multiply</span><span class="p">(</span><span class="n">mat4</span><span class="p">,</span> <span class="n">vec4</span><span class="p">,</span> <span class="n">res4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div>

<p><strong>递归模板</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">func</span>
<span class="k">def</span> <span class="nf">sum_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">l</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;编译时递归模板&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">):</span>
        <span class="c1"># 基础情况：直接求和</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># 递归情况：分治</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">sum_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">+</span> <span class="n">sum_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div>

<h3 id="174">1.7.4 静态类型推导</h3>
<p>Taichi的类型系统支持编译时类型推导：</p>
<p><strong>自动类型推导</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">type_deduction_example</span><span class="p">():</span>
    <span class="c1"># 自动推导类型</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span>  <span class="c1"># ti.i32</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mf">3.14</span>  <span class="c1"># ti.f32</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>  <span class="c1"># ti.f32 (自动提升)</span>

    <span class="c1"># 向量类型推导</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># ti.types.vector(3, ti.i32)</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>  <span class="c1"># ti.types.vector(3, ti.f32)</span>
    <span class="n">v3</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>  <span class="c1"># ti.types.vector(3, ti.f32)</span>
</code></pre></div>

<p><strong>泛型函数</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">func</span>
<span class="k">def</span> <span class="nf">generic_norm</span><span class="p">(</span><span class="n">vec</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;自动推导返回类型&quot;&quot;&quot;</span>
    <span class="n">norm_sqr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">static</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">n</span><span class="p">)):</span>
        <span class="n">norm_sqr</span> <span class="o">+=</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ti</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm_sqr</span><span class="p">)</span>

<span class="c1"># 可用于不同精度</span>
<span class="n">vec_f32</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span>
<span class="n">norm_f32</span> <span class="o">=</span> <span class="n">generic_norm</span><span class="p">(</span><span class="n">vec_f32</span><span class="p">)</span>  <span class="c1"># 返回f32</span>

<span class="n">vec_f64</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">Vector</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span> <span class="n">dt</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f64</span><span class="p">)</span>  
<span class="n">norm_f64</span> <span class="o">=</span> <span class="n">generic_norm</span><span class="p">(</span><span class="n">vec_f64</span><span class="p">)</span>  <span class="c1"># 返回f64</span>
</code></pre></div>

<p><strong>类型约束</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">type_constrained</span><span class="p">(</span><span class="n">field</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;明确的类型约束&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">ndrange</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

<span class="c1"># 只接受2D f32数组</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">type_constrained</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>  <span class="c1"># OK</span>

<span class="c1"># arr_3d = np.random.rand(10, 10, 10).astype(np.float32)</span>
<span class="c1"># type_constrained(arr_3d)  # 编译错误：维度不匹配</span>
</code></pre></div>

<h2 id="_2">本章小结</h2>
<p>本章全面介绍了基于物理的动画和Taichi编程语言的核心概念：</p>
<p><strong>关键概念回顾</strong>：</p>
<ol>
<li><strong>物理引擎基础</strong>：理解了物理仿真在游戏、电影和工程中的应用，以及实时性与精确性的权衡</li>
<li><strong>Taichi语言特性</strong>：掌握了kernel/func、张量操作、自动并行化等核心功能</li>
<li><strong>编程范式</strong>：
   - DOP：数据布局优化（AoS vs SoA）、缓存友好设计、向量化
   - OOP：类封装、ODOP模式、组件化设计
   - MP：模板编程、维度通用代码、编译时优化</li>
</ol>
<p><strong>重要公式和算法</strong>：</p>
<ul>
<li>稳定性条件：$\Delta t \leq c\sqrt{\frac{m}{k}}$（显式积分器）</li>
<li>缓存访问时间：L1(~4 cycles) &lt; L2(~12 cycles) &lt; L3(~40 cycles) &lt; 主存(~200 cycles)</li>
<li>并行效率：$E = \frac{S}{p} = \frac{T_1}{p \cdot T_p}$，其中S是加速比，p是处理器数</li>
</ul>
<p><strong>性能优化要点</strong>：</p>
<ol>
<li>数据局部性：行优先访问、分块算法、预取</li>
<li>并行化：避免竞态条件、减少原子操作、负载均衡</li>
<li>向量化：SIMD友好的数据布局、循环展开、避免分支</li>
</ol>
<h2 id="_3">练习题</h2>
<h3 id="_4">基础题（熟悉材料）</h3>
<p><strong>练习1.1</strong>：编写一个Taichi kernel，计算两个向量场的点积。要求支持任意维度。</p>
<details>
<summary>提示</summary>
<p>使用<code>ti.template()</code>和<code>ti.grouped()</code>实现维度无关的代码。</p>
</details>
<details>
<summary>参考答案</summary>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">vector_field_dot</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">b</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">ti</span><span class="o">.</span><span class="n">f32</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">ti</span><span class="o">.</span><span class="n">grouped</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">I</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>

<p>关键点：使用<code>ti.grouped</code>遍历任意维度的field，利用向量的<code>dot</code>方法计算点积。</p>
</details>
<p><strong>练习1.2</strong>：比较AoS和SoA布局在粒子系统更新中的性能差异。实现两个版本并测量执行时间。</p>
<details>
<summary>提示</summary>
<p>分别实现只更新位置和更新所有属性两种情况，观察哪种布局更优。</p>
</details>
<details>
<summary>参考答案</summary>
<p>AoS在访问单个粒子的所有属性时更优（如碰撞检测），SoA在批量更新单一属性时更优（如位置更新）。具体性能差异取决于：</p>
<ul>
<li>缓存行大小（通常64字节）</li>
<li>SIMD向量宽度</li>
<li>访问模式的规律性</li>
</ul>
<p>测量结果通常显示SoA在纯位置更新时快2-4倍。</p>
</details>
<p><strong>练习1.3</strong>：实现一个线程安全的直方图统计kernel，统计0-255范围内整数的出现频率。</p>
<details>
<summary>提示</summary>
<p>考虑使用原子操作，但要注意优化策略减少冲突。</p>
</details>
<details>
<summary>参考答案</summary>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">(),</span> <span class="n">hist</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
    <span class="c1"># 清零</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
        <span class="n">hist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># 统计</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="n">hist</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p>优化版本可以使用线程局部数组减少原子操作频率。</p>
</details>
<p><strong>练习1.4</strong>：使用Taichi的调试功能找出以下代码的错误：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">buggy_kernel</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 有bug</span>
</code></pre></div>

<details>
<summary>提示</summary>
<p>考虑边界条件和数组访问范围。</p>
</details>
<details>
<summary>参考答案</summary>
<p>当<code>i = arr.shape[0] - 1</code>时，<code>arr[i+1]</code>会越界。修正：</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">fixed_kernel</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ti</span><span class="o">.</span><span class="n">template</span><span class="p">()):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>

</details>
<h3 id="_5">挑战题（深入思考）</h3>
<p><strong>练习1.5</strong>：设计并实现一个高效的2D空间哈希数据结构，支持动态插入和范围查询。要求：</p>
<ul>
<li>支持百万级粒子</li>
<li>查询半径内的所有邻居</li>
<li>处理非均匀分布</li>
</ul>
<details>
<summary>提示</summary>
<p>考虑使用多级网格或自适应网格大小，处理稀疏和密集区域。</p>
</details>
<details>
<summary>参考答案</summary>
<p>关键设计要点：</p>
<ol>
<li>使用质数表大小减少哈希冲突</li>
<li>链表处理冲突，但要考虑内存局部性</li>
<li>动态调整网格大小基于局部密度</li>
<li>使用Morton编码保持空间局部性</li>
</ol>
<p>性能优化：</p>
<ul>
<li>预分配内存池避免动态分配</li>
<li>使用原子操作并行构建</li>
<li>定期重建以保持效率</li>
</ul>
</details>
<p><strong>练习1.6</strong>：实现一个通用的归约（reduction）框架，支持任意二元操作和数据类型。要求在GPU上达到接近峰值带宽。</p>
<details>
<summary>提示</summary>
<p>考虑warp-level primitives、shared memory使用、多级归约策略。</p>
</details>
<details>
<summary>参考答案</summary>
<p>高效归约的关键技术：</p>
<ol>
<li><strong>Warp内归约</strong>：利用warp shuffle指令避免共享内存</li>
<li><strong>多级策略</strong>：warp级→block级→grid级</li>
<li><strong>负载均衡</strong>：每个线程处理多个元素</li>
<li><strong>内存访问</strong>：合并访问模式，避免bank冲突</li>
</ol>
<p>理论分析：</p>
<ul>
<li>带宽利用率 = 实际带宽 / 峰值带宽</li>
<li>目标：达到80%以上的带宽利用率</li>
<li>瓶颈：最后几步的并行度下降</li>
</ul>
</details>
<p><strong>练习1.7</strong>：使用元编程技术实现一个编译时计算的快速傅里叶变换（FFT）。支持2的幂次大小。</p>
<details>
<summary>提示</summary>
<p>使用<code>ti.static</code>展开蝶形操作，预计算旋转因子。</p>
</details>
<details>
<summary>参考答案</summary>
<p>元编程FFT的要点：</p>
<ol>
<li>编译时确定FFT大小和迭代次数</li>
<li>静态展开所有循环层级</li>
<li>预计算twiddle factors为常量</li>
<li>使用位反转的查表实现</li>
</ol>
<p>性能考虑：</p>
<ul>
<li>寄存器压力vs循环开销权衡</li>
<li>共享内存bank冲突避免</li>
<li>适合小尺寸FFT（≤1024点）</li>
</ul>
</details>
<p><strong>练习1.8</strong>：设计一个物理引擎的整体架构，整合本章所学的所有概念。包括：</p>
<ul>
<li>模块化设计（碰撞检测、约束求解、积分器）</li>
<li>数据结构选择（粒子、刚体、约束）</li>
<li>并行化策略</li>
<li>可扩展性考虑</li>
</ul>
<details>
<summary>提示</summary>
<p>参考现代物理引擎如Bullet、PhysX的设计，但要考虑Taichi的特点。</p>
</details>
<details>
<summary>参考答案</summary>
<p>架构设计要点：</p>
<ol>
<li>
<p><strong>核心模块</strong>：
   - BroadPhase：空间划分，快速剔除
   - NarrowPhase：精确碰撞检测
   - ConstraintSolver：约束求解（PGS/SI）
   - Integrator：时间积分（插件式）</p>
</li>
<li>
<p><strong>数据组织</strong>：
   - ECS模式：实体-组件-系统
   - SoA布局：性能优化
   - 双缓冲：避免竞态</p>
</li>
<li>
<p><strong>并行策略</strong>：
   - 空间分区并行
   - 图着色避免冲突
   - 任务图调度</p>
</li>
<li>
<p><strong>扩展性</strong>：
   - 插件式力场
   - 自定义约束
   - 脚本绑定</p>
</li>
</ol>
</details>
<h2 id="_6">常见陷阱与错误</h2>
<h3 id="1">1. 并行编程陷阱</h3>
<p><strong>陷阱1</strong>：假设kernel内的执行顺序</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 错误：依赖执行顺序</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">wrong</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 并行执行，顺序不确定！</span>
</code></pre></div>

<p><strong>解决</strong>：使用串行循环或改变算法</p>
<p><strong>陷阱2</strong>：过度使用原子操作</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 低效：大量原子操作</span>
<span class="nd">@ti</span><span class="o">.</span><span class="n">kernel</span>
<span class="k">def</span> <span class="nf">inefficient</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
        <span class="n">ti</span><span class="o">.</span><span class="n">atomic_add</span><span class="p">(</span><span class="nb">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># 严重的串行化</span>
</code></pre></div>

<p><strong>解决</strong>：使用归约或线程局部累加</p>
<h3 id="2">2. 内存访问陷阱</h3>
<p><strong>陷阱3</strong>：列主序访问二维数组</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 缓存不友好</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">process</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>  <span class="c1"># 跨步访问</span>
</code></pre></div>

<p><strong>解决</strong>：调整循环顺序或转置数据</p>
<p><strong>陷阱4</strong>：伪共享</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 多线程写入相邻内存</span>
<span class="n">counters</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">ti</span><span class="o">.</span><span class="n">i32</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
<span class="c1"># 不同线程的counter可能在同一缓存行</span>
</code></pre></div>

<p><strong>解决</strong>：添加填充或使用线程局部变量</p>
<h3 id="3">3. 类型系统陷阱</h3>
<p><strong>陷阱5</strong>：整数除法精度损失</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 意外的整数除法</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># 在kernel中可能是1而非1.5</span>
</code></pre></div>

<p><strong>解决</strong>：显式使用浮点数或转换类型</p>
<h3 id="4">4. 调试陷阱</h3>
<p><strong>陷阱6</strong>：GPU调试时忘记同步</p>
<div class="codehilite"><pre><span></span><code><span class="n">kernel</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 可能读到旧值！</span>
</code></pre></div>

<p><strong>解决</strong>：添加<code>ti.sync()</code>确保GPU完成</p>
<h2 id="_7">最佳实践检查清单</h2>
<h3 id="_8">设计阶段</h3>
<ul>
<li>[ ] 选择合适的数据布局（AoS/SoA/AoSoA）</li>
<li>[ ] 识别并行化机会和数据依赖</li>
<li>[ ] 考虑缓存友好的算法设计</li>
<li>[ ] 规划内存使用和数据流</li>
</ul>
<h3 id="_9">实现阶段</h3>
<ul>
<li>[ ] 使用<code>ti.template()</code>编写通用代码</li>
<li>[ ] 最小化原子操作使用</li>
<li>[ ] 确保内存访问模式合理</li>
<li>[ ] 适当使用<code>ti.static</code>优化</li>
</ul>
<h3 id="_10">优化阶段</h3>
<ul>
<li>[ ] 使用性能分析工具定位瓶颈</li>
<li>[ ] 考虑向量化和循环展开</li>
<li>[ ] 平衡计算与内存访问</li>
<li>[ ] 验证并行正确性</li>
</ul>
<h3 id="_11">调试阶段</h3>
<ul>
<li>[ ] 启用调试模式进行边界检查</li>
<li>[ ] 使用小数据集验证正确性</li>
<li>[ ] 添加断言检查不变量</li>
<li>[ ] 记录性能基准用于回归测试</li>
</ul>
<h3 id="_12">代码质量</h3>
<ul>
<li>[ ] 遵循ODOP设计模式</li>
<li>[ ] 模块化和可测试性</li>
<li>[ ] 文档化性能关键决策</li>
<li>[ ] 考虑跨平台兼容性</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="./index.html" class="nav-link prev">← 高级物理引擎实战教程</a><a href="./chapter2.html" class="nav-link next">第二章：拉格朗日视角（1） →</a></nav>
        </main>
    </div>
</body>
</html>